/*
 * LiquidBounce+ Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/WYSI-Foundation/LiquidBouncePlus/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.features.module.modules.exploit.helper.PacketThread
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.*
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.network.handshake.client.C00Handshake
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.*
import io.netty.buffer.Unpooled
import net.minecraft.network.Packet
import net.minecraft.network.PacketBuffer
import net.minecraft.util.BlockPos
import net.minecraft.util.EnumFacing
import net.minecraft.world.WorldSettings.GameType

import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.IOException
import java.util.LinkedList

import kotlin.math.sqrt
import kotlin.math.round

@ModuleInfo(name = "CustomDisabler", spacedName = "Custom Disabler", description = "Disabler but fully customizable. Contains 20+ options.", category = ModuleCategory.EXPLOIT)
class CustomDisabler : Module() {

	private val minRand: IntegerValue = object : IntegerValue("FakeLag-MinDelay", 0, 0, 20000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = maxRand.get()
            if (v < newValue) set(v)
        }
    }
    private val maxRand: IntegerValue = object : IntegerValue("FakeLag-MaxDelay", 0, 0, 20000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = minRand.get()
            if (v > newValue) set(v)
        }
    }

	private val transEnabled = BoolValue("Transactions", false)
	private val aliveEnabled = BoolValue("KeepAlive", false)
	private val transDelayMode = ListValue("Transactions-DelayMode", arrayOf("PlayerTick", "SystemTick", "Dynamic", "BusSize"), "Dynamic")
	private val aliveDelayMode = ListValue("KeepAlive-DelayMode", arrayOf("PlayerTick", "SystemTick", "Dynamic", "BusSize"), "Dynamic")
	private val transBusMinSize = IntegerValue("Transactions-MinBusSize", 0, 0, 300)
	private val aliveBusMinSize = IntegerValue("KeepAlive-MinBusSize", 0, 0, 300)
	private val transDynamicDupe = BoolValue("Transactions-DynamicDupe", false)
	private val aliveDynamicDupe = BoolValue("KeepAlive-DynamicDupe", false)
	private val transDupe = IntegerValue("Transactions-DupeAmount", 1, 1, 100)
	private val aliveDupe = IntegerValue("KeepAlive-DupeAmount", 1, 1, 100)
	private val transAsync = BoolValue("Transactions-Async", false)
	private val aliveAsync = BoolValue("KeepAlive-Async", false)
	private val flushWhenDisable = BoolValue("Flush-When-Disable", false)
	private val debugValue = BoolValue("Debug", false)

	private val trans = hashMapOf<Long, C0FPacketConfirmTransaction>()
	private val alive = hashMapOf<Long, C00PacketKeepAlive>()
	
	private val msTimer = MSTimer()

	fun debug(s: String) {
		if (debugValue.get())
			ClientUtils.displayChatMessage("§7[§3§lDisabler§7]§f $s")
	}

	fun isTDynamic(): Boolean = transDelayMode.get().equals("dynamic", true)
	fun isADynamic(): Boolean = aliveDelayMode.get().equals("dynamic", true)

	override fun onEnable() {
		alive.clear()
		trans.clear()
		msTimer.reset()
	}

	override fun onDisable() {
		if (flushWhenDisable.get()) {
			for ((t, packet) in alive) {
				PacketUtils.sendPacketNoEvent(packet)
			}
			for ((t, packet) in trans) {
				PacketUtils.sendPacketNoEvent(packet)
			}
		}

		alive.clear()
		trans.clear()
		msTimer.reset()

		mc.timer.timerSpeed = 1F
	}

	@EventTarget
	fun onPacket(event: PacketEvent) {
		val packet = event.packet
	
	}

	@EventTarget
	fun onMotion(event: MotionEvent) {
	}

	@EventTarget
	fun onWorld(event: WorldEvent) {
		alive.clear()
		trans.clear()
		msTimer.reset()
	}

	@EventTarget
	fun onUpdate(event: UpdateEvent) {
	}
}