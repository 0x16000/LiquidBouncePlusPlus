/*
 * LiquidBounce+ Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/WYSI-Foundation/LiquidBouncePlus/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.*
import io.netty.buffer.Unpooled
import net.minecraft.network.Packet
import net.minecraft.network.PacketBuffer
import net.minecraft.util.BlockPos
import net.minecraft.world.WorldSettings

import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.IOException

@ModuleInfo(name = "Disabler", description = "Disable some anticheats' checks.", category = ModuleCategory.EXPLOIT)
class Disabler : Module() {

	private val modeValue = ListValue("Mode", 
		arrayOf(
			"Basic",
			"Verus-Combat", 
			"Old-Matrix", 
			"Kauri", 
			"Riding-Spoof", 
			"Area51", 
			"Spartan-Combat", 
			"Old-Ghostly",
			"Spectate-Spoof",
			"Spectate-Spoof2",
			"Spectate",
			"Test",
			"Creative-Spoof",
			"Gamemode-Spoof",
			"IDFK"
		), "Basic")

	private val gameModeValue = ListValue("Game-Mode", arrayOf("Survival", "Creative", "Spectator", "Adventure", "Not_Set"), "Survival")

	private val debugValue = BoolValue("Debug", false)

	private val keepAlives = arrayListOf<C00PacketKeepAlive>()
	private val transactions = arrayListOf<C0FPacketConfirmTransaction>()
	private val msTimer = MSTimer()

	private var lastGamemode : WorldSettings.GameType = WorldSettings.GameType.SURVIVAL

	override fun onEnable() {
		keepAlives.clear()
		transactions.clear()
		msTimer.reset()
		lastGamemode = mc.playerController.currentGameType
	}

	override fun onDisable() {
		// make sure to send all missing packets so the anticheat won't be angry
		keepAlives.forEach {
			PacketUtils.sendPacketNoEvent(it)
		}
		transactions.forEach {
			PacketUtils.sendPacketNoEvent(it)
		}
		keepAlives.clear()
		transactions.clear()
		msTimer.reset()
		mc.playerController.setGameType(lastGamemode)
	}

	@EventTarget
	fun onPacket(event: PacketEvent) {
		when (modeValue.get()) {
			"Verus-Combat" -> if (event.packet is C0FPacketConfirmTransaction || event.packet is C0BPacketEntityAction) event.cancelEvent()
			"Old-Matrix" -> if (event.packet is C03PacketPlayer && mc.thePlayer.ticksExisted % 15 == 0) {
				try {
					val b = ByteArrayOutputStream()
	                val _out = DataOutputStream(b)
	                _out.writeUTF(mc.thePlayer.gameProfile.getName())
	                val buf = PacketBuffer(Unpooled.buffer())
	                buf.writeBytes(b.toByteArray())
	                mc.netHandler.addToSendQueue(C17PacketCustomPayload("matrix:geyser", buf))
				} catch (e: IOException) {

				}
			}
			"Kauri" -> if (event.packet is C0FPacketConfirmTransaction) event.cancelEvent()
			"Riding-Spoof" -> if (event.packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C0CPacketInput(mc.thePlayer.moveStrafing, mc.thePlayer.moveForward, mc.thePlayer.movementInput.jump, mc.thePlayer.movementInput.sneak))
			"Basic" -> if (event.packet is C0FPacketConfirmTransaction || event.packet is C00PacketKeepAlive) event.cancelEvent()
			"Old-Ghostly" -> {
				if (event.packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C0CPacketInput())
				if (event.packet is C0FPacketConfirmTransaction || event.packet is C00PacketKeepAlive) event.cancelEvent()
			}
			"Spartan-Combat" -> {
				var packet = event.packet
        		if (packet is C00PacketKeepAlive && (keepAlives.size <= 0 || packet != keepAlives.get(keepAlives.size - 1))) {
            		keepAlives.add(packet)
            		event.cancelEvent()
        		}
        		if (packet is C0FPacketConfirmTransaction && (transactions.size <= 0 || packet != transactions.get(transactions.size - 1))) {
            		transactions.add(packet)
            		event.cancelEvent()
        		}
			}
			"Spectate-Spoof" -> {
				if (event.packet is C03PacketPlayer) {
					val c03 = event.packet as C03PacketPlayer
					c03.onGround = false

					val capabilities = PlayerCapabilities()
					capabilities.disableDamage = true
					capabilities.isFlying = true
					capabilities.allowFlying = true
					capabilities.isCreativeMode = false

					mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
					mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
				}
			}
			"Spectate-Spoof2" -> {
				if (event.packet is C03PacketPlayer) {
					val capabilities = PlayerCapabilities()
					capabilities.disableDamage = true
					capabilities.isFlying = true
					capabilities.allowFlying = true
					capabilities.isCreativeMode = false

					mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
					mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
				}
			}
			"Spectate" -> {
				if (event.packet is C03PacketPlayer)
					mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
			}
			"Test" -> {
				val packet = event.packet
				if (packet is C03PacketPlayer) {
					packet.onGround = false

					val capabilities = PlayerCapabilities()
					capabilities.disableDamage = true
					capabilities.allowFlying = true
					capabilities.isCreativeMode = true

					mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
					mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
				}

				if (packet is C0FPacketConfirmTransaction) {
					if (debugValue.get()) ClientUtils.displayChatMessage("c0f ${packet.uid} ${packet.windowId}")
					transactions.add(packet)
					event.cancelEvent()
				}
			}
			"Gamemode-Spoof" -> {
				val packet = event.packet
				if (packet is S2BPacketChangeGameState)
					event.cancelEvent()
				if (packet is S01PacketJoinGame) {
					try {
						val gameType = WorldSettings.GameType.valueOf(gameModeValue.get().toUpperCase())
						if (packet.gameType != lastGamemode) 
							lastGamemode = packet.gameType
					} catch (e: Exception) {
						// idc
					}
				}
				if (packet is S07PacketRespawn) {
					try {
						val gameType = WorldSettings.GameType.valueOf(gameModeValue.get().toUpperCase())
						if (packet.gameType != lastGamemode) 
							lastGamemode = packet.gameType
					} catch (e: Exception) {
						// idc
					}
				}
			}
			"IDFK" -> {
				val packet = event.packet
				if (packet is C03PacketPlayer) {
					packet.onGround = false

					val capabilities = PlayerCapabilities()
					capabilities.disableDamage = true
					capabilities.isFlying = false
					capabilities.allowFlying = false
					capabilities.isCreativeMode = false

					mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
					mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
				}

				if (packet is S32PacketConfirmTransaction || packet is S2BPacketChangeGameState)
					event.cancelEvent()
			}
		}
	}

	@EventTarget
	fun onWorld(event: WorldEvent) {
		transactions.clear()
		keepAlives.clear()
		msTimer.reset()
	}

	@EventTarget
	fun onUpdate(event: UpdateEvent) {
		if (modeValue.get().equals("area51", true)) mc.netHandler.addToSendQueue(C08PacketPlayerBlockPlacement(BlockPos(Double.NaN, Double.NaN, Double.NaN), 1, null, 0F, 0F, 0F))
		if (modeValue.get().equals("spartan-combat", true) && keepAlives.size > 0 && transactions.size > 0) {
			if (msTimer.hasTimePassed(3000L)) {
				PacketUtils.sendPacketNoEvent(keepAlives.get(keepAlives.size - 1))
				PacketUtils.sendPacketNoEvent(transactions.get(transactions.size - 1))
				keepAlives.clear()
				transactions.clear()
				msTimer.reset()
			}
		}
		if (modeValue.get().equals("test", true) && mc.thePlayer.ticksExisted % 22 == 0) {
			if (!transactions.isEmpty()) {
				transactions.forEach {
					PacketUtils.sendPacketNoEvent(it)
					if (debugValue.get()) ClientUtils.displayChatMessage("${it.uid} sent with WID ${it.windowId}")
				}
				transactions.clear()
			}
		}
		if (modeValue.get().equals("creative-spoof", true)) {
			mc.thePlayer.capabilities.allowFlying = true
			mc.thePlayer.capabilities.disableDamage = true
			mc.thePlayer.capabilities.isCreativeMode = true
		}
		if (modeValue.get().equals("Gamemode-Spoof", true)) {
			try {
				val gameType = WorldSettings.GameType.valueOf(gameModeValue.get().toUpperCase())
				if (mc.playerController.currentGameType != gameType) 
					mc.playerController.setGameType(gameType)
			} catch (e: Exception) {
				// idc
			}
		}
		if (modeValue.get().equals("idfk", true)) 
			mc.playerController.setGameType(WorldSettings.GameType.NOT_SET)
	}
}