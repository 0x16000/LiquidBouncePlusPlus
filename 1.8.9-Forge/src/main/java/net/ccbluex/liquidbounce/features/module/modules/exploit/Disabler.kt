/*
 * LiquidBounce+ Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/WYSI-Foundation/LiquidBouncePlus/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.network.handshake.client.C00Handshake
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.*
import io.netty.buffer.Unpooled
import net.minecraft.network.Packet
import net.minecraft.network.PacketBuffer
import net.minecraft.util.BlockPos

import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.IOException

@ModuleInfo(name = "Disabler", description = "Disable some anticheats' checks.", category = ModuleCategory.EXPLOIT)
class Disabler : Module() {

	private val modeValue = ListValue("Mode", 
		arrayOf(
			"Basic",
			"VerusCombatOld", 
			"OldMatrix", 
			"Kauri", 
			"RidingSpoof", 
			"SpartanCombat", 
			"OldGhostly",
			"Spectate",
			"VulcanGeyserTest",
			"NullPlace",
			"C13+InfiniteC0C",
			"NoGroundTouch",
			"NoGroundTouch2",
			"NoIdea",
			"InfiniteYPos",
			"NaNYPos",
			"InfiniteYPos2",
			"NaNYPos2",
			"NaNYPos3",
			"TrueAbilities",
			"GhostlyV2",
			"Sloth",
			"CavePvP",
			"NoPingNoTransaction",
			"NCPDamage"
		), "Basic")

	private val sendTPValue = BoolValue("NoIdea-SendTP", true)
	private val sendDelayValue = IntegerValue("NoIdea-TPDelay", 3000, 0, 10000)

	private val keepAlives = arrayListOf<C00PacketKeepAlive>()
	private val transactions = arrayListOf<C0FPacketConfirmTransaction>()
	private val msTimer = MSTimer()

	override fun onEnable() {
		keepAlives.clear()
		transactions.clear()
		msTimer.reset()

		if (mc.thePlayer == null) return
		if (modeValue.get().equals("noidea", true)) 
			mc.thePlayer.sendQueue.addToSendQueue(C13PacketPlayerAbilities(mc.thePlayer.capabilities))

		if (modeValue.get().equals("cavepvp", true)) {
			for (i in 0..19) {
				PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,
						mc.thePlayer.posY + 0.300001, mc.thePlayer.posZ, false))
				PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,
						mc.thePlayer.posY, mc.thePlayer.posZ, false))
			}
			PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
		}

		if (modeValue.get().equals("ncpdamage", true)) {
			for (i in 0..9) {
				PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,
						mc.thePlayer.posY + 0.300001, mc.thePlayer.posZ, false))
				PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,
						mc.thePlayer.posY, mc.thePlayer.posZ, false))
			}
			PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
		}

		mc.thePlayer.ticksExisted = 0
	}

	override fun onDisable() {
		// make sure to send all missing packets so the anticheat won't be angry
		keepAlives.forEach {
			PacketUtils.sendPacketNoEvent(it)
		}
		transactions.forEach {
			PacketUtils.sendPacketNoEvent(it)
		}
		keepAlives.clear()
		transactions.clear()
		msTimer.reset()

		mc.thePlayer.motionY = 0.0
		MovementUtils.strafe(0F)
		mc.timer.timerSpeed = 1F
		if (mc.playerController.gameIsSurvivalOrAdventure()) {
			mc.thePlayer.capabilities.allowFlying = false
		} else if (mc.playerController.isInCreativeMode()) {
			mc.thePlayer.capabilities.allowFlying = true
		} else {
			mc.thePlayer.capabilities.allowFlying = true
		}
	}

	@EventTarget
	fun onPacket(event: PacketEvent) {
		val packet = event.packet
	
		when (modeValue.get()) {
			"VerusCombatOld" -> if (packet is C0FPacketConfirmTransaction || packet is C0BPacketEntityAction) event.cancelEvent()
			"OldMatrix" -> if (packet is C03PacketPlayer && mc.thePlayer.ticksExisted % 15 == 0) {
				try {
					val b = ByteArrayOutputStream()
	                val _out = DataOutputStream(b)
	                _out.writeUTF(mc.thePlayer.gameProfile.getName())
	                val buf = PacketBuffer(Unpooled.buffer())
	                buf.writeBytes(b.toByteArray())
	                mc.netHandler.addToSendQueue(C17PacketCustomPayload("matrix:geyser", buf))
				} catch (e: IOException) {

				}
			}
			"VulcanGeyserTest" -> if (packet is C03PacketPlayer && mc.thePlayer.ticksExisted % 15 == 0) {
				try {
					val b = ByteArrayOutputStream()
	                val _out = DataOutputStream(b)
	                _out.writeUTF(mc.thePlayer.gameProfile.getName())
	                val buf = PacketBuffer(Unpooled.buffer())
	                buf.writeBytes(b.toByteArray())
	                mc.netHandler.addToSendQueue(C17PacketCustomPayload("vulcan:geyser", buf))
				} catch (e: IOException) {

				}
			}
			"Kauri" -> if (packet is C0FPacketConfirmTransaction) event.cancelEvent()
			"RidingSpoof" -> if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C0CPacketInput(mc.thePlayer.moveStrafing, mc.thePlayer.moveForward, mc.thePlayer.movementInput.jump, mc.thePlayer.movementInput.sneak))
			"Basic" -> if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) event.cancelEvent()
			"OldGhostly" -> {
				if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C0CPacketInput())
				if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) event.cancelEvent()
			}
			"SpartanCombat" -> {
        		if (packet is C00PacketKeepAlive && (keepAlives.size <= 0 || packet != keepAlives[keepAlives.size - 1])) {
            		keepAlives.add(packet)
            		event.cancelEvent()
        		}
        		if (packet is C0FPacketConfirmTransaction && (transactions.size <= 0 || packet != transactions[transactions.size - 1])) {
            		transactions.add(packet)
            		event.cancelEvent()
        		}
			}
			"Spectate" -> {
				if (packet is C03PacketPlayer)
					mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
			}
			"NoGroundTouch2" -> {
				if (packet is C03PacketPlayer)
					packet.y += 0.125
			}
			"InfiniteYPos2" -> {
				if (packet is C03PacketPlayer)
					packet.y = if (RandomUtils.nextBoolean()) Double.MAX_VALUE else Double.MIN_VALUE
			}
			"NaNYPos2" -> {
				if (packet is C03PacketPlayer)
					packet.y = if (RandomUtils.nextBoolean()) Double.POSITIVE_INFINITY else Double.NEGATIVE_INFINITY
			}
			"NaNYPos3" -> {
				if (packet is C03PacketPlayer)
					packet.y = Double.NaN
			}
			"TrueAbilities" -> {
				if (packet is C13PacketPlayerAbilities) {
					packet.setAllowFlying(true)
					packet.setCreativeMode(true)
					packet.setFlying(true)
					packet.setInvulnerable(true)
				}
				if (packet is S39PacketPlayerAbilities) {
					packet.setAllowFlying(true)
					packet.setCreativeMode(true)
					packet.setFlying(true)
					packet.setInvulnerable(true)
				}
			}
			"CavePvP" -> {
				if (packet is C00PacketKeepAlive || packet is S00PacketKeepAlive || packet is C00Handshake)
					event.cancelEvent()
				if (packet is C13PacketPlayerAbilities) {
					packet.setAllowFlying(true)
					packet.setCreativeMode(true)
					packet.setFlying(true)
					packet.setInvulnerable(true)
				}
				if (packet is S39PacketPlayerAbilities) {
					packet.setAllowFlying(true)
					packet.setCreativeMode(true)
					packet.setFlying(true)
					packet.setInvulnerable(true)
				}
				if (mc.thePlayer.ticksExisted > 3 && packet is C03PacketPlayer) 
					packet.onGround = false
			}
			"NoIdea" -> {
				if (packet is C03PacketPlayer
					|| packet is C03PacketPlayer.C04PacketPlayerPosition
					|| packet is C03PacketPlayer.C05PacketPlayerLook
					|| packet is C03PacketPlayer.C06PacketPlayerPosLook) {
					val packetC03 = packet as C03PacketPlayer
					packetC03.y += Double.MIN_VALUE
					packetC03.onGround = true
				}
				if (packet is C13PacketPlayerAbilities) {
					packet.setAllowFlying(true)
					packet.setCreativeMode(true)
					packet.setFlying(true)
					packet.setInvulnerable(true)
				}
				if (packet is S39PacketPlayerAbilities) {
					packet.setAllowFlying(true)
					packet.setCreativeMode(true)
					packet.setFlying(true)
					packet.setInvulnerable(true)
				}
			}
			"NoPingNoTransaction" -> {
				if (packet is C00PacketKeepAlive || packet is S00PacketKeepAlive
					|| packet is C00Handshake
					|| packet is C0FPacketConfirmTransaction || packet is S32PacketConfirmTransaction)
					event.cancelEvent()
			}
			"GhostlyV2" -> {
				if (packet is C00PacketKeepAlive || packet is S00PacketKeepAlive || packet is C00Handshake)
					event.cancelEvent()
			}
		}
	}

	@EventTarget
	fun onWorld(event: WorldEvent) {
		transactions.clear()
		keepAlives.clear()
		msTimer.reset()
	}

	@EventTarget
	fun onUpdate(event: UpdateEvent) {
		if (modeValue.get().equals("nullplace", true)) {
			PacketUtils.sendPacketNoEvent(C08PacketPlayerBlockPlacement(
								BlockPos(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY,
										Double.POSITIVE_INFINITY),
								Integer.MAX_VALUE, null, Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY,
								Float.POSITIVE_INFINITY));
			PacketUtils.sendPacketNoEvent(C08PacketPlayerBlockPlacement(
								BlockPos(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY,
										Double.NEGATIVE_INFINITY),
								Integer.MAX_VALUE, null, Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY,
								Float.NEGATIVE_INFINITY));
			PacketUtils.sendPacketNoEvent(C08PacketPlayerBlockPlacement(
						BlockPos(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ), 0, null, 0F, 0F, 0F));
		}
		if (modeValue.get().equals("spartancombat", true) && keepAlives.size > 0 && transactions.size > 0) {
			if (msTimer.hasTimePassed(3000L)) {
				PacketUtils.sendPacketNoEvent(keepAlives[keepAlives.size - 1])
				PacketUtils.sendPacketNoEvent(transactions[transactions.size - 1])
				keepAlives.clear()
				transactions.clear()
				msTimer.reset()
			}
		}
		if (modeValue.get().equals("nogroundtouch", true)) {
			PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,
						mc.thePlayer.posY + .125, mc.thePlayer.posZ, true))
		}
		if (modeValue.get().equals("c13+infinitec0c", true)) {
			PacketUtils.sendPacketNoEvent(C13PacketPlayerAbilities(mc.thePlayer.capabilities));
			PacketUtils.sendPacketNoEvent(C0CPacketInput(Float.MAX_VALUE, Float.MAX_VALUE, false, false));
		}
		if (modeValue.get().equals("sloth", true)) {
			if (mc.thePlayer.ticksExisted < 100) {
				for (i in 0..1) {
					for (a in 0..4) {
						PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(
								mc.thePlayer.posX, mc.thePlayer.posY + 1.0, mc.thePlayer.posZ, false))
					}
					for (b in 0..4) {
						PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(
								mc.thePlayer.posX, mc.thePlayer.posY + 0.5, mc.thePlayer.posZ, false))
					}
					for (c in 0..4) {
						PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(
								mc.thePlayer.posX, mc.thePlayer.posY + 0.01, mc.thePlayer.posZ, true))
					}
				}
			}
		}
		if (modeValue.get().equals("ghostlyv2", true)) {
			if (mc.thePlayer.ticksExisted < 25)
				PacketUtils.sendPacketNoEvent(C00PacketKeepAlive())
		}
	}
}